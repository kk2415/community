server:
  port: 8080
  servlet:
    session:
      tracking-modes: COOKIE
      timeout: 1800

spring:
  application:
    name: levelup

  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/level_up?serverTimezone=Asia/Seoul
    username: root
    password: Dudrhkd10ck!
    schema: classpath:schema.sql

  jpa:
    hibernate:
      ddl-auto:
    properties:
      hibernate:
        show_sql: true
        format_sql:
        default_batch_fetch_size: 100 #컬렉션에서 있는 모든 엔티티에 select 쿼리를 날리지 않고 IN 절로 한 번에 조회
        #장점
        #   쿼리 호출 수가 1 + N 1 + 1 로 최적화 된다.
        #   조인보다 DB 데이터 전송량이 최적화 된다. (Order와 OrderItem을 조인하면 Order가
        #   OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.)
        #   페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다.
        #   컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.
        #결론
        #   ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로
        #   쿼리 수를 줄이고 해결하고, 나머지는 hibernate.default_batch_fetch_size 로 최적화 하자.

    #    open-in-view: true
    #OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. 따라서
    #커넥션 리소스를 낭비하지 않는다.

  servlet:
    multipart:
      max-file-size: 1MB
      max-request-size: 10MB

  mail:
    host: smtp.gmail.com
    port: 587
    properties:
      mail:
        debug: true
        smtp:
          connectiontimeout: 5000
          auth: true
          starttls:
            enable: true
            required: true

file:
  window_local_dir: C:/Task/study/levelup
  linux_local_dir: /tmp
  s3_dir: https://levelupbuckets3.s3.ap-northeast-2.amazonaws.com


logging.level:
  org.hibernate.SQL: debug

# org.hibernate.type: trace

#logging:
#  level:
#    org:
#      apache:
#        coyote:
#          http11=debug:
# 위 옵션은 http 요청 메시지를 확인할 수 있는 옵션